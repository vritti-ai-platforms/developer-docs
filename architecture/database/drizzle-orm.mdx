---
title: Drizzle ORM
description: Why we chose Drizzle and how it's configured
---

Vritti uses **Drizzle ORM** for database access. Drizzle provides type-safe SQL queries with excellent TypeScript integration and a lightweight runtime.

## Why Drizzle Over Prisma?

<CardGroup cols={2}>
  <Card title="SQL-First Design" icon="database">
    Drizzle generates SQL you can understand and optimize. No magic query translation.
  </Card>
  <Card title="No Code Generation" icon="bolt">
    Schema is TypeScript code - no `prisma generate` step. Changes are instant.
  </Card>
  <Card title="Lightweight Runtime" icon="feather">
    ~7KB runtime vs Prisma's ~2MB. Faster cold starts in serverless.
  </Card>
  <Card title="Multi-Tenant Ready" icon="building">
    Dynamic database connections work seamlessly. Prisma requires client recreation.
  </Card>
</CardGroup>

## Version

We use Drizzle ORM v1 (beta):

```json
{
  "drizzle-orm": "1.0.0-beta.3-36e9b9e",
  "drizzle-kit": "1.0.0-beta.3-36e9b9e"
}
```

## Configuration

### Drizzle Config

```typescript
// vritti-api-nexus/drizzle.config.ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'postgresql',
  schema: './src/db/schema/index.ts',
  out: './src/db/migrations',

  // Use direct connection URL (bypasses pgBouncer)
  dbCredentials: {
    url: process.env.PRIMARY_DB_DATABASE_DIRECT_URL!,
  },

  // Only manage the 'cloud' schema
  schemaFilter: ['cloud'],

  verbose: true,
  strict: true,
});
```

### Database Connection

```typescript
// Using node-postgres (pg) driver
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 10, // Connection pool size
});

export const db = drizzle(pool, {
  schema,
  logger: process.env.NODE_ENV === 'development',
});
```

## Schema Definition

### PostgreSQL Schema Namespace

```typescript
// src/db/schema/cloud-schema.ts
import { pgSchema } from 'drizzle-orm/pg-core';

// All tables live in the 'cloud' schema
export const cloudSchema = pgSchema('cloud');
```

### Table Definition

```typescript
// src/db/schema/user.ts
import { cloudSchema } from './cloud-schema';
import { accountStatusEnum, onboardingStepEnum } from './enums';

export const users = cloudSchema.table('users', {
  // Primary key
  id: uuid('id').primaryKey().defaultRandom(),

  // Basic fields
  email: varchar('email', { length: 255 }).notNull().unique(),
  phone: varchar('phone', { length: 20 }),
  locale: varchar('locale', { length: 10 }).default('en'),
  timezone: varchar('timezone', { length: 50 }).default('UTC'),

  // Status tracking
  accountStatus: accountStatusEnum('account_status').notNull().default('PENDING_VERIFICATION'),
  currentOnboardingStep: onboardingStepEnum('current_onboarding_step').default('EMAIL_VERIFICATION'),

  // Verification flags
  emailVerified: boolean('email_verified').notNull().default(false),
  phoneVerified: boolean('phone_verified').notNull().default(false),
  mfaEnabled: boolean('mfa_enabled').notNull().default(false),

  // Timestamps
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),
});

// Type inference
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
```

### Enum Definition

```typescript
// src/db/schema/enums.ts
import { cloudSchema } from './cloud-schema';

export const accountStatusEnum = cloudSchema.enum('account_status', [
  'PENDING_VERIFICATION',
  'ACTIVE',
  'INACTIVE',
]);

export const onboardingStepEnum = cloudSchema.enum('onboarding_step', [
  'EMAIL_VERIFICATION',
  'SET_PASSWORD',
  'MOBILE_VERIFICATION',
  'TWO_FACTOR_SETUP',
  'COMPLETE',
]);

export const tenantStatusEnum = cloudSchema.enum('tenant_status', [
  'ACTIVE',
  'SUSPENDED',
  'ARCHIVED',
]);
```

## Relations

Drizzle v1 uses `defineRelations` for relationship definitions:

```typescript
// src/db/schema/relations.ts
import { defineRelations } from 'drizzle-orm';
import { tenants, tenantDatabaseConfigs, users, sessions } from './';

export const relations = defineRelations(schema, (r) => ({
  // Tenant has one database config
  tenants: r.one.tenantDatabaseConfigs({
    from: tenantDatabaseConfigs.tenantId,
    to: tenants.id,
    alias: 'databaseConfig',
  }),

  // User has many sessions
  users: r.many.sessions({
    from: users.id,
    to: sessions.userId,
    alias: 'sessions',
  }),
}));
```

## Query Patterns

### Basic CRUD

```typescript
// Create
const user = await db.insert(users).values({
  email: 'user@example.com',
}).returning();

// Read
const user = await db.select().from(users).where(eq(users.id, userId));

// Update
await db.update(users)
  .set({ emailVerified: true })
  .where(eq(users.id, userId));

// Delete
await db.delete(users).where(eq(users.id, userId));
```

### Relational Queries

```typescript
// Fetch tenant with database config
const tenant = await db.query.tenants.findFirst({
  where: eq(tenants.subdomain, 'acme'),
  with: {
    databaseConfig: true,
  },
});

// Fetch user with sessions
const user = await db.query.users.findFirst({
  where: eq(users.email, email),
  with: {
    sessions: {
      where: gt(sessions.expiresAt, new Date()),
    },
  },
});
```

### Complex Queries

```typescript
// Join with aggregation
const result = await db
  .select({
    tenantId: tenants.id,
    subdomain: tenants.subdomain,
    userCount: count(users.id),
  })
  .from(tenants)
  .leftJoin(users, eq(users.tenantId, tenants.id))
  .groupBy(tenants.id)
  .having(gt(count(users.id), 10));
```

## Repository Pattern

Vritti uses base repository classes from `@vritti/api-sdk`:

### Primary Repository (for cloud schema)

```typescript
@Injectable()
export class UserRepository extends PrimaryBaseRepository<typeof users> {
  constructor(primaryDb: PrimaryDatabaseService) {
    super(primaryDb, users);
  }

  async findByEmail(email: string) {
    return this.db.query.users.findFirst({
      where: eq(users.email, email),
    });
  }
}
```

### Tenant Repository (for tenant databases)

```typescript
@Injectable()
export class ProductRepository extends TenantBaseRepository<typeof products> {
  constructor(tenantDb: TenantDatabaseService) {
    super(tenantDb, products);
  }

  // Queries automatically use current tenant's database
  async findByCategory(categoryId: string) {
    return this.db.query.products.findMany({
      where: eq(products.categoryId, categoryId),
    });
  }
}
```

## Type Safety

Drizzle provides compile-time type checking:

```typescript
// This fails at compile time
await db.insert(users).values({
  email: 123, // Type error: number is not string
});

// This fails at compile time
const user = await db.select().from(users);
console.log(user.nonExistentField); // Type error: property doesn't exist

// Inferred types
type User = typeof users.$inferSelect;
// {
//   id: string;
//   email: string;
//   phone: string | null;
//   emailVerified: boolean;
//   ...
// }
```

## Transactions

```typescript
await db.transaction(async (tx) => {
  // Create user
  const [user] = await tx.insert(users)
    .values({ email })
    .returning();

  // Create initial session
  await tx.insert(sessions)
    .values({
      userId: user.id,
      type: 'ONBOARDING',
      expiresAt: new Date(Date.now() + 3600000),
    });

  return user;
});
```

## SDK Re-exports

The `@vritti/api-sdk` re-exports Drizzle for consistent versioning:

```typescript
// api-sdk/src/drizzle-orm.ts
export * from 'drizzle-orm';

// api-sdk/src/drizzle-pg-core.ts
export * from 'drizzle-orm/pg-core';

// Usage in vritti-api-nexus
import { eq, and, or } from '@vritti/api-sdk/drizzle-orm';
import { pgTable, varchar, uuid } from '@vritti/api-sdk/drizzle-pg-core';
```

## Using DatabaseModule

The `@vritti/api-sdk` provides `DatabaseModule` for multi-tenant database management. It offers two configuration modes depending on your application type.

### Server Mode (HTTP APIs)

For HTTP APIs that need tenant routing and the primary database:

```typescript
import { DatabaseModule } from '@vritti/api-sdk';
import * as schema from './db/schema';
import * as relations from './db/relations';

@Module({
  imports: [
    DatabaseModule.forServer({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        // Primary database (tenant registry)
        primaryDb: {
          host: config.get('DB_HOST'),
          port: config.get('DB_PORT'),
          username: config.get('DB_USER'),
          password: config.get('DB_PASSWORD'),
          database: config.get('DB_NAME'),
          schema: 'public',
          sslMode: 'disable',
        },

        // Drizzle schema and relations
        drizzleSchema: schema,
        drizzleRelations: relations,

        // Connection settings
        connectionCacheTTL: 300000,  // 5 minutes
        maxConnections: 10,
      }),
    }),
  ],
})
export class AppModule {}
```

### Microservice Mode

For message-based services (RabbitMQ workers) that don't need the primary database:

```typescript
DatabaseModule.forMicroservice({
  useFactory: () => ({
    drizzleSchema: schema,
    drizzleRelations: relations,
    // No primary DB - tenant info comes from messages
  }),
})
```

### Database Services

The `DatabaseModule` provides three services:

**PrimaryDatabaseService** - Access to primary database (tenant registry):
```typescript
import { PrimaryDatabaseService } from '@vritti/api-sdk';

@Injectable()
export class TenantService {
  constructor(private primaryDb: PrimaryDatabaseService) {}

  async getTenantBySubdomain(subdomain: string) {
    return this.primaryDb.getTenantInfo(subdomain);
  }

  // Access Drizzle client directly
  async customQuery() {
    const db = this.primaryDb.drizzleClient;
    return db.query.tenants.findMany({
      where: eq(tenants.status, 'ACTIVE'),
    });
  }
}
```

| Method | Description |
|--------|-------------|
| `getTenantInfo(identifier)` | Get tenant by ID or subdomain |
| `clearTenantCache(identifier)` | Clear cached tenant config |
| `clearAllCaches()` | Clear all tenant caches |
| `drizzleClient` | Raw Drizzle client access |

**TenantDatabaseService** - Request-scoped tenant database connections:
```typescript
import { TenantDatabaseService } from '@vritti/api-sdk';

@Injectable()
export class UserService {
  constructor(private tenantDb: TenantDatabaseService) {}

  async findUsers() {
    const db = await this.tenantDb.getConnection();
    return db.query.users.findMany();
  }
}
```

Features:
- Connection pooling per tenant
- Automatic cleanup of idle connections
- Supports SHARED and DEDICATED schemas

**TenantContextService** - Request-scoped tenant state:
```typescript
import { TenantContextService } from '@vritti/api-sdk';

@Injectable()
export class AuditService {
  constructor(private tenantContext: TenantContextService) {}

  async logAction(action: string) {
    const tenant = this.tenantContext.getTenant();
    console.log(`[${tenant.subdomain}] ${action}`);
  }
}
```

| Method | Description |
|--------|-------------|
| `setTenant(info)` | Set tenant (called by interceptor) |
| `getTenant()` | Get tenant (throws if not set) |
| `hasTenant()` | Check if tenant is set |
| `getTenantIdSafe()` | Get tenant ID or null |
| `getTenantSubdomainSafe()` | Get subdomain or null |
| `clearTenant()` | Clear tenant context |

## Base Repository Classes

The `@vritti/api-sdk` provides base repository classes that abstract common CRUD operations and provide type-safe data access.

### PrimaryBaseRepository

For querying the primary database (tenant registry, global data):

```typescript
import { PrimaryBaseRepository, PrimaryDatabaseService } from '@vritti/api-sdk';
import { tenants } from './db/schema';

@Injectable()
export class TenantRepository extends PrimaryBaseRepository<typeof tenants> {
  constructor(database: PrimaryDatabaseService) {
    super(database, tenants);
  }

  // Custom methods
  async findBySubdomain(subdomain: string) {
    return this.model.findFirst({
      where: { subdomain },
    });
  }

  async findActiveWithUsers() {
    return this.model.findMany({
      where: { status: 'ACTIVE' },
      with: { users: true },
    });
  }
}
```

### TenantBaseRepository

For querying tenant-specific databases:

```typescript
import { TenantBaseRepository, TenantDatabaseService } from '@vritti/api-sdk';
import { users } from './db/schema';

@Injectable()
export class UserRepository extends TenantBaseRepository<typeof users> {
  constructor(database: TenantDatabaseService) {
    super(database, users);
  }

  // Queries automatically use current tenant's database
  async findByEmail(email: string) {
    return this.model.findFirst({
      where: { email },
      with: { profile: true },
    });
  }

  async findActiveUsers() {
    return this.model.findMany({
      where: { status: 'ACTIVE' },
      orderBy: { createdAt: 'desc' },
    });
  }
}
```

### Base Repository Methods

Both base classes provide these CRUD methods:

```typescript
// Create
create(data: TInsert): Promise<TSelect>

// Read
findById(id: string): Promise<TSelect | undefined>
findOne(where: WhereFilter): Promise<TSelect | undefined>
findMany(options?): Promise<TSelect[]>
count(where?): Promise<number>
exists(where): Promise<boolean>

// Update
update(id: string, data: Partial<TInsert>): Promise<TSelect>
updateMany(where: WhereFilter, data: Partial<TInsert>): Promise<{ count: number }>

// Delete
delete(id: string): Promise<TSelect>
deleteMany(where: WhereFilter): Promise<{ count: number }>
```

### Accessing the Drizzle Model

For complex queries, access the Drizzle relational model directly:

```typescript
// Using relational API (recommended)
async findWithRelations() {
  return this.model.findMany({
    where: { status: 'ACTIVE' },
    with: {
      profile: true,
      orders: {
        where: { status: 'PENDING' },
        limit: 10,
      },
    },
  });
}

// Using raw Drizzle client for complex queries
async complexQuery() {
  const db = this.db;
  return db
    .select()
    .from(users)
    .leftJoin(orders, eq(users.id, orders.userId))
    .where(and(
      eq(users.status, 'ACTIVE'),
      gt(orders.total, 100)
    ));
}
```

## Multi-Tenant Database Patterns

Vritti supports two multi-tenancy patterns:

### Shared Schema Pattern

Multiple tenants in the same database, different PostgreSQL schemas:

```
Database: vritti_production
├── tenant_acme (schema)
│   ├── users
│   ├── orders
│   └── products
├── tenant_globex (schema)
│   ├── users
│   ├── orders
│   └── products
```

**Pros:**
- Lower infrastructure costs
- Easier to manage (single database)
- Simpler backup/restore

**Cons:**
- Shared resources (CPU, memory, connections)
- Less isolation between tenants
- Harder to scale individual tenants

### Dedicated Database Pattern

Each tenant has a separate database:

```
├── vritti_acme (database)
│   └── public (schema)
│       ├── users
│       ├── orders
│       └── products
├── vritti_globex (database)
│   └── public (schema)
│       ├── users
│       ├── orders
│       └── products
```

**Pros:**
- Complete resource isolation
- Easy to scale individual tenants
- Better security boundaries
- Can backup/restore individual tenants

**Cons:**
- Higher infrastructure costs
- More complex management
- Connection pooling per database

### Tenant Configuration

Tenant database config is stored in the primary database's `tenantDatabaseConfigs` table:

```typescript
// Primary DB - tenantDatabaseConfigs table
{
  tenantId: 'ten_123',
  type: 'SHARED',         // or 'DEDICATED'
  host: 'localhost',
  port: 5432,
  database: 'vritti_production',
  schema: 'tenant_acme',  // For SHARED type
  username: 'app_user',
  password: 'encrypted...',  // Encrypted with EncryptionService
  sslMode: 'disable',
  connectionPoolSize: 10,
}
```

### Schema Registry

For type-safe Drizzle clients, augment the schema registry:

```typescript
// src/db/schema-registry.ts
declare module '@vritti/api-sdk' {
  interface SchemaRegistry {
    schema: typeof import('./schema');
  }
}

export {};
```

This enables full TypeScript inference:

```typescript
// db.query.users is now fully typed
const user = await db.query.users.findFirst({
  where: { email },
  with: { profile: true },
});
// user.profile is typed correctly
```

## Connection Pooling and Caching

The `DatabaseModule` implements intelligent connection pooling:

**Connection Caching:**
- Tenant database connections are cached based on tenant ID
- Cache TTL is configurable (default: 5 minutes)
- Idle connections are automatically cleaned up

**Pool Configuration:**
```typescript
DatabaseModule.forServer({
  useFactory: (config) => ({
    primaryDb: { /* ... */ },
    connectionCacheTTL: 300000,  // 5 minutes
    maxConnections: 10,           // Per tenant pool size
  }),
})
```

**Best Practices:**
- Configure `connectionCacheTTL` based on traffic patterns
- Set `maxConnections` based on expected concurrent requests
- Monitor connection pool metrics
- Use read replicas for read-heavy workloads

## Next Steps

<CardGroup cols={2}>
  <Card title="Service Patterns" icon="layer-group" href="/architecture/backend/service-patterns">
    Learn repository and service patterns
  </Card>
  <Card title="Schema Overview" icon="table" href="/architecture/database/schema-overview">
    See all database tables
  </Card>
  <Card title="Migrations" icon="code-branch" href="/architecture/database/migrations">
    Learn migration workflow
  </Card>
  <Card title="Multi-Tenancy" icon="building" href="/architecture/backend/multi-tenancy">
    Deep dive into tenant isolation
  </Card>
</CardGroup>
