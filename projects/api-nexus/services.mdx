---
title: Service Implementations
description: Key service implementations in vritti-api-nexus
---

This guide shows specific service implementations in vritti-api-nexus. For general service patterns and architectural guidelines, see the [Service Layer Patterns](/architecture/backend/service-patterns) documentation.

## Overview

vritti-api-nexus implements the following key services:

- **AuthService** - User authentication and session management
- **OnboardingService** - User registration and verification flow
- **UserService** - User profile and account management
- **TenantService** - Tenant provisioning and configuration
- **SessionService** - Session lifecycle management

All services follow the [layered architecture pattern](/architecture/backend/service-patterns#layered-architecture) with clear separation between controllers, services, and repositories.

## Example Service Implementations

### AuthService

Handles user authentication with multiple dependencies:

```typescript
// src/auth/auth.service.ts
@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly sessionService: SessionService,
    private readonly jwtService: JwtAuthService,
    private readonly configService: ConfigService,
  ) {}

  async login(dto: LoginDto) {
    // 1. Find and validate user
    const user = await this.userService.findByEmail(dto.email);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // 2. Verify password
    const isValid = await this.verifyPassword(dto.password, user.passwordHash);
    if (!isValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // 3. Check MFA requirement
    if (user.mfaEnabled) {
      return { requiresMfa: true, userId: user.id };
    }

    // 4. Create session and generate tokens
    const session = await this.sessionService.create(user.id, 'CLOUD');
    const tokens = await this.jwtService.generateTokens(user, session);

    return { user, tokens };
  }

  async logout(userId: string, sessionId: string) {
    await this.sessionService.revoke(sessionId, userId);
    return { success: true };
  }

  private async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
}
```

**Key Patterns Used:**
- Multiple dependency injection (UserService, SessionService, JwtAuthService)
- Explicit error handling with domain-specific exceptions
- Business logic separated from HTTP concerns
- Private helper methods for internal operations

### OnboardingService

Manages user registration and verification with event emission:

```typescript
// src/onboarding/onboarding.service.ts
@Injectable()
export class OnboardingService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly otpService: OtpService,
    private readonly emailService: EmailService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  async verifyEmail(userId: string, otp: string) {
    // 1. Validate OTP
    const isValid = await this.otpService.verify(userId, otp, 'EMAIL');
    if (!isValid) {
      throw new BadRequestException('Invalid or expired OTP');
    }

    // 2. Update user status
    await this.userRepository.update(userId, {
      emailVerified: true,
      currentOnboardingStep: 'SET_PASSWORD',
    });

    // 3. Emit event for listeners
    this.eventEmitter.emit('verification.completed', {
      userId,
      type: 'email',
      timestamp: new Date(),
    });

    return { success: true, nextStep: 'SET_PASSWORD' };
  }

  async sendVerificationEmail(email: string, userId: string) {
    const otp = await this.otpService.generate(userId, 'EMAIL');
    await this.emailService.sendVerificationEmail(email, otp);
    return { success: true };
  }
}
```

**Key Patterns Used:**
- [Event-driven communication](/architecture/backend/service-patterns#event-driven-communication) for decoupled notifications
- OTP service for verification code management
- Status tracking through onboarding steps
- Integration with shared EmailService

### UserService

Standard CRUD service with business rules:

```typescript
// src/users/user.service.ts
@Injectable()
export class UserService {
  constructor(
    private readonly userRepository: UserRepository,
  ) {}

  async findById(id: string) {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new NotFoundException(`User ${id} not found`);
    }
    return user;
  }

  async findByEmail(email: string) {
    return this.userRepository.findByEmail(email);
  }

  async create(dto: CreateUserDto) {
    // Business rule: Check for duplicates
    const existing = await this.userRepository.findByEmail(dto.email);
    if (existing) {
      throw new ConflictException('Email already registered');
    }

    // Business logic: Set initial state
    const user = await this.userRepository.create({
      ...dto,
      accountStatus: 'PENDING_VERIFICATION',
      currentOnboardingStep: 'EMAIL_VERIFICATION',
    });

    return user;
  }

  async update(id: string, dto: UpdateUserDto) {
    await this.findById(id); // Validates existence
    return this.userRepository.update(id, dto);
  }
}
```

**Key Patterns Used:**
- Single repository dependency
- Existence validation before operations
- Business rules enforced in service layer
- Explicit error handling

## Shared Services

vritti-api-nexus provides shared services that can be used across modules:

### EmailService

Brevo integration for transactional emails. See [Service Patterns - EmailService](/architecture/backend/service-patterns#emailservice) for details.

**Usage in api-nexus:**
```typescript
await this.emailService.sendVerificationEmail(email, otp);
await this.emailService.sendWelcomeEmail(email, name);
```

### WhatsAppService

WhatsApp Cloud API integration. See [Service Patterns - WhatsAppService](/architecture/backend/service-patterns#whatsappservice) for details.

**Usage in api-nexus:**
```typescript
await this.whatsAppService.sendVerificationMessage(phone, otp);
const isValid = this.whatsAppService.verifyWebhookSignature(payload, signature);
```

### EncryptionService

AES-256-GCM encryption for sensitive data. See [Service Patterns - EncryptionService](/architecture/backend/service-patterns#encryptionservice) for details.

**Usage in api-nexus:**
```typescript
const encrypted = this.encryptionService.encrypt(plaintext);
const decrypted = this.encryptionService.decrypt(ciphertext);
```

## Repository Implementations

vritti-api-nexus repositories extend base classes from `@vritti/api-sdk`:

### UserRepository

```typescript
// src/users/user.repository.ts
@Injectable()
export class UserRepository extends PrimaryBaseRepository<typeof users> {
  constructor(database: PrimaryDatabaseService) {
    super(database, users);
  }

  async findByEmail(email: string) {
    return this.model.findFirst({
      where: { email: email.toLowerCase() },
    });
  }

  async findActiveUsers(limit = 100, offset = 0) {
    return this.model.findMany({
      where: { accountStatus: 'ACTIVE' },
      limit,
      offset,
    });
  }

  async updateOnboardingStep(userId: string, step: OnboardingStep) {
    return this.update(userId, { currentOnboardingStep: step });
  }
}
```

For repository patterns and base class methods, see [Service Patterns - Repository Pattern](/architecture/backend/service-patterns#repository-pattern).

## Testing Services

Service tests should mock dependencies and focus on business logic:

```typescript
describe('AuthService', () => {
  let service: AuthService;
  let userService: jest.Mocked<UserService>;
  let sessionService: jest.Mocked<SessionService>;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: UserService,
          useValue: { findByEmail: jest.fn() },
        },
        {
          provide: SessionService,
          useValue: { create: jest.fn() },
        },
        {
          provide: JwtAuthService,
          useValue: { generateTokens: jest.fn() },
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    userService = module.get(UserService);
    sessionService = module.get(SessionService);
  });

  it('should login user with valid credentials', async () => {
    const user = { id: 'usr_123', email: 'test@example.com', passwordHash: 'hash' };
    userService.findByEmail.mockResolvedValue(user);

    const result = await service.login({
      email: 'test@example.com',
      password: 'password',
    });

    expect(result).toHaveProperty('tokens');
    expect(sessionService.create).toHaveBeenCalled();
  });

  it('should throw UnauthorizedException for invalid credentials', async () => {
    userService.findByEmail.mockResolvedValue(null);

    await expect(
      service.login({ email: 'test@example.com', password: 'wrong' })
    ).rejects.toThrow(UnauthorizedException);
  });
});
```

For comprehensive testing guidance, see the [Testing Guide](/projects/api-nexus/testing).

## Related Documentation

<CardGroup cols={2}>
  <Card title="Service Patterns" icon="layer-group" href="/architecture/backend/service-patterns">
    Layered architecture and service design patterns
  </Card>
  <Card title="Repository Pattern" icon="database" href="/architecture/backend/service-patterns#repository-pattern">
    Base repository classes and query patterns
  </Card>
  <Card title="Error Handling" icon="exclamation-triangle" href="/architecture/backend/service-patterns#error-handling-patterns">
    Custom exceptions and error responses
  </Card>
  <Card title="Testing Guide" icon="flask" href="/projects/api-nexus/testing">
    How to test services and repositories
  </Card>
</CardGroup>
