---
title: "Setting Up Module Federation"
description: "Module Federation configuration for vritti-web-nexus"
---

This guide shows how to set up Module Federation in the vritti-web-nexus host application.

For Module Federation concepts, architecture, and patterns, see [Module Federation](/architecture/frontend/module-federation).

## Quick Setup

### 1. Configure RSBuild

The Module Federation plugin is configured in `rsbuild.config.ts`:

```typescript
import { defineConfig } from '@rsbuild/core';
import { pluginReact } from '@rsbuild/plugin-react';
import { pluginModuleFederation } from '@module-federation/rsbuild-plugin';

export default defineConfig({
  plugins: [
    pluginReact(),
    pluginModuleFederation({
      name: 'vritti_nexus_host',
      remotes: {}, // Runtime registration
      shared: {
        react: {
          singleton: true,
          requiredVersion: '^19.2.0',
          eager: true,
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^19.2.0',
          eager: true,
        },
        'react-router-dom': {
          singleton: true,
          eager: true,
        },
        '@vritti/quantum-ui': {
          singleton: true,
          eager: true,
        },
        axios: {
          singleton: true,
          eager: true,
        },
        '@tanstack/react-query': {
          singleton: true,
          eager: true,
        },
      },
    }),
  ],
  server: {
    port: 3012,
    host: 'local.vrittiai.com',
  },
});
```

### 2. Define Remote Configuration

Create `src/config/remotes.config.ts`:

```typescript
export interface RemoteConfig {
  name: string;
  entry: string;
  exposedModule: string;
}

export const ALL_REMOTES: RemoteConfig[] = [
  {
    name: 'VrittiAuth',
    entry: process.env.PUBLIC_VRITTI_AUTH_ENTRY ||
           'http://local.vrittiai.com:3001/mf-manifest.json',
    exposedModule: 'routes',
  },
  // Add future remotes here
];
```

### 3. Register Remotes in Bootstrap

Update `src/bootstrap.tsx` to register remotes before rendering:

```typescript
import { registerRemotes } from '@module-federation/runtime';
import { createRoot } from 'react-dom/client';
import { StrictMode } from 'react';
import { configureQuantumUI } from '@vritti/quantum-ui';
import { ALL_REMOTES } from './config/remotes.config';
import quantumUIConfig from './config/quantum-ui.config';

// Configure quantum-ui (for session recovery)
configureQuantumUI(quantumUIConfig);

// Register all remotes at startup
registerRemotes(
  ALL_REMOTES.map((remote) => ({
    name: remote.name,
    entry: remote.entry,
  }))
);

// Render the app
const root = createRoot(document.getElementById('root')!);
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

### 4. Create RemoteRoutes Component

Create `src/utils/RemoteRoutes.tsx` to load remote modules:

```typescript
import { loadRemote } from '@module-federation/runtime';
import { useEffect, useState } from 'react';
import { RouteObject, useRoutes } from 'react-router-dom';
import { MicrofrontendSkeletonFullPage } from '@vritti/quantum-ui';

interface RemoteRoutesProps {
  remoteName: string;
  moduleName: string;
  dataKey?: string;
}

// Cache loaded modules
const moduleCache = new Map<string, unknown>();

async function loadRemoteModule(remoteName: string, moduleName: string) {
  const cacheKey = `${remoteName}/${moduleName}`;

  if (moduleCache.has(cacheKey)) {
    return moduleCache.get(cacheKey);
  }

  const module = await loadRemote(`${remoteName}/${moduleName}`);
  const result = module.default || module;

  moduleCache.set(cacheKey, result);
  return result;
}

export function RemoteRoutes({
  remoteName,
  moduleName,
  dataKey
}: RemoteRoutesProps) {
  const [routes, setRoutes] = useState<RouteObject[] | null>(null);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    loadRemoteModule(remoteName, moduleName)
      .then((module) => {
        const routeData = dataKey ? module[dataKey] : module;
        setRoutes(routeData);
      })
      .catch(setError);
  }, [remoteName, moduleName, dataKey]);

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen">
        <h2 className="text-2xl font-bold mb-4">Failed to load {remoteName}</h2>
        <p className="text-gray-600 mb-4">{error.message}</p>
        <button
          onClick={() => window.location.reload()}
          className="px-4 py-2 bg-blue-600 text-white rounded"
        >
          Retry
        </button>
      </div>
    );
  }

  if (!routes) {
    return <MicrofrontendSkeletonFullPage />;
  }

  return <>{useRoutes(routes)}</>;
}
```

### 5. Use RemoteRoutes in Routes

Update `src/routes.tsx` to conditionally load remote modules:

```typescript
import { RouteObject } from 'react-router-dom';
import { RemoteRoutes } from './utils/RemoteRoutes';
import { LoadingPage } from './pages/LoadingPage';

const isCloud = window.location.hostname.startsWith('cloud.');

export const routes: RouteObject[] = [
  { path: '/', element: <LoadingPage /> },
];

if (isCloud) {
  routes.push({
    path: '/*',
    element: (
      <RemoteRoutes
        remoteName="VrittiAuth"
        moduleName="routes"
        dataKey="authRoutes"
      />
    ),
  });
}
```

## Adding New Remotes

To add a new remote application:

### Step 1: Add to Remote Config

```typescript
// src/config/remotes.config.ts
export const ALL_REMOTES: RemoteConfig[] = [
  {
    name: 'VrittiAuth',
    entry: 'http://local.vrittiai.com:3001/mf-manifest.json',
    exposedModule: 'routes',
  },
  {
    name: 'VrittiDashboard', // New remote
    entry: 'http://local.vrittiai.com:3003/mf-manifest.json',
    exposedModule: 'routes',
  },
];
```

### Step 2: Add Routes

```typescript
// src/routes.tsx
if (isCloud) {
  routes.push(
    {
      path: '/auth/*',
      element: <RemoteRoutes remoteName="VrittiAuth" moduleName="routes" />,
    },
    {
      path: '/dashboard/*',
      element: <RemoteRoutes remoteName="VrittiDashboard" moduleName="routes" />,
    }
  );
}
```

## Development Workflow

Start the remote application first, then the host:

```bash
# Terminal 1: Start remote
cd vritti-auth
pnpm dev
# Manifest: http://local.vrittiai.com:3001/mf-manifest.json

# Terminal 2: Start host
cd vritti-web-nexus
pnpm dev
# App: http://local.vrittiai.com:3012
```

Verify the integration:
1. Open http://local.vrittiai.com:3012
2. Navigate to `/login` (or other auth routes)
3. Routes should load from the remote

## Debugging

### Check Module Loading

Add logging to see when modules load:

```typescript
async function loadRemoteModule(remoteName: string, moduleName: string) {
  console.log(`[MF] Loading: ${remoteName}/${moduleName}`);

  const module = await loadRemote(`${remoteName}/${moduleName}`);

  console.log(`[MF] Loaded:`, module);
  return module;
}
```

### Network Inspection

In browser DevTools Network tab, verify:
- `mf-manifest.json` loads successfully (200 OK)
- Remote entry JS file loads
- No 404 errors on chunks

### Common Issues

**Manifest not loading:**
- Ensure remote app is running
- Check `/etc/hosts` has `127.0.0.1 local.vrittiai.com`
- Verify manifest URL is accessible

**React hooks error:**
- Ensure `singleton: true` for React in both host and remote configs
- Verify same React version in both `package.json` files

**Module not found:**
- Add `eager: true` to shared dependencies
- Ensure package is installed in both applications

## Next Steps

<CardGroup cols={2}>
  <Card title="Module Federation" icon="cubes" href="/architecture/frontend/module-federation">
    Learn about Module Federation architecture and patterns
  </Card>
  <Card title="Micro-Frontends" icon="puzzle-piece" href="/architecture/frontend/micro-frontends">
    Understand micro-frontend patterns
  </Card>
  <Card title="vritti-auth" icon="user-lock" href="/projects/auth/overview">
    Configure the auth remote application
  </Card>
  <Card title="Web Nexus Overview" icon="house" href="/projects/web-nexus/overview">
    Back to project overview
  </Card>
</CardGroup>
