---
title: "Getting Started with DatabaseModule"
description: "Quick start guide for using @vritti/api-sdk database features"
---

The `@vritti/api-sdk` provides multi-tenant database support with Drizzle ORM. This guide shows how to get started using the `DatabaseModule` in your NestJS application.

For architectural concepts and patterns, see [Drizzle ORM Architecture](/architecture/database/drizzle-orm).

## Installation

The `@vritti/api-sdk` package includes Drizzle ORM dependencies:

```bash
npm install @vritti/api-sdk
```

## Basic Setup

### 1. Configure DatabaseModule

Import and configure the `DatabaseModule` in your app module:

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { DatabaseModule } from '@vritti/api-sdk';
import * as schema from './db/schema';
import * as relations from './db/relations';

@Module({
  imports: [
    ConfigModule.forRoot(),
    DatabaseModule.forServer({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        primaryDb: {
          host: config.get('DB_HOST'),
          port: config.get('DB_PORT'),
          username: config.get('DB_USER'),
          password: config.get('DB_PASSWORD'),
          database: config.get('DB_NAME'),
          schema: 'public',
          sslMode: 'disable',
        },
        drizzleSchema: schema,
        drizzleRelations: relations,
        connectionCacheTTL: 300000,
        maxConnections: 10,
      }),
    }),
  ],
})
export class AppModule {}
```

### 2. Use in Services

Inject the database services in your repositories and services:

```typescript
import { Injectable } from '@nestjs/common';
import { PrimaryDatabaseService } from '@vritti/api-sdk';
import { tenants } from './db/schema';

@Injectable()
export class TenantService {
  constructor(private readonly primaryDb: PrimaryDatabaseService) {}

  async getTenantBySubdomain(subdomain: string) {
    return this.primaryDb.getTenantInfo(subdomain);
  }

  async getAllTenants() {
    const db = this.primaryDb.drizzleClient;
    return db.query.tenants.findMany({
      where: { status: 'ACTIVE' },
    });
  }
}
```

## Using Base Repositories

The SDK provides base repository classes for common CRUD operations:

### PrimaryBaseRepository

For querying the primary database:

```typescript
import { Injectable } from '@nestjs/common';
import { PrimaryBaseRepository, PrimaryDatabaseService } from '@vritti/api-sdk';
import { tenants } from './db/schema';

@Injectable()
export class TenantRepository extends PrimaryBaseRepository<typeof tenants> {
  constructor(database: PrimaryDatabaseService) {
    super(database, tenants);
  }

  // Inherits: create, findById, findOne, findMany, update, delete

  // Add custom queries
  async findBySubdomain(subdomain: string) {
    return this.model.findFirst({
      where: { subdomain },
    });
  }
}
```

### TenantBaseRepository

For querying tenant-specific databases:

```typescript
import { Injectable } from '@nestjs/common';
import { TenantBaseRepository, TenantDatabaseService } from '@vritti/api-sdk';
import { users } from './db/schema';

@Injectable()
export class UserRepository extends TenantBaseRepository<typeof users> {
  constructor(database: TenantDatabaseService) {
    super(database, users);
  }

  // Queries automatically use current tenant's database
  async findByEmail(email: string) {
    return this.model.findFirst({
      where: { email },
    });
  }
}
```

## Type Safety with Schema Registry

For full TypeScript inference, augment the schema registry:

```typescript
// src/db/schema-registry.ts
declare module '@vritti/api-sdk' {
  interface SchemaRegistry {
    schema: typeof import('./schema');
  }
}

export {};
```

This enables fully-typed queries:

```typescript
const user = await db.query.users.findFirst({
  where: { email },
  with: { profile: true },
});
// user.profile is correctly typed
```

## Importing Drizzle Utilities

Use the SDK's Drizzle re-exports for consistent versions:

```typescript
// Query operators
import { eq, and, or, gt, lt, like } from '@vritti/api-sdk/drizzle-orm';

// Schema definitions
import { pgTable, text, timestamp, integer } from '@vritti/api-sdk/drizzle-pg-core';

// Usage
const activeUsers = await db
  .select()
  .from(users)
  .where(and(
    eq(users.status, 'ACTIVE'),
    gt(users.createdAt, lastWeek)
  ));
```

## Microservice Configuration

For message-based services (without HTTP/tenant routing):

```typescript
DatabaseModule.forMicroservice({
  useFactory: () => ({
    drizzleSchema: schema,
    drizzleRelations: relations,
    // No primary DB - tenant info from messages
  }),
})
```

## Quick Reference

### Database Services

| Service | Purpose |
|---------|---------|
| `PrimaryDatabaseService` | Access primary database (tenant registry) |
| `TenantDatabaseService` | Access tenant-specific databases |
| `TenantContextService` | Get current tenant context |

### Base Repository Methods

Both `PrimaryBaseRepository` and `TenantBaseRepository` provide:

```typescript
// Create
create(data): Promise<T>

// Read
findById(id): Promise<T | undefined>
findOne(where): Promise<T | undefined>
findMany(options?): Promise<T[]>
count(where?): Promise<number>
exists(where): Promise<boolean>

// Update
update(id, data): Promise<T>
updateMany(where, data): Promise<{ count: number }>

// Delete
delete(id): Promise<T>
deleteMany(where): Promise<{ count: number }>
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Drizzle ORM Architecture" icon="database" href="/architecture/database/drizzle-orm">
    Learn about multi-tenant patterns and connection pooling
  </Card>
  <Card title="Service Patterns" icon="layer-group" href="/architecture/backend/service-patterns">
    Understand repository and service layer patterns
  </Card>
  <Card title="Schema Overview" icon="table" href="/architecture/database/schema-overview">
    See all database tables and relationships
  </Card>
  <Card title="Migrations" icon="code-branch" href="/architecture/database/migrations">
    Learn the migration workflow
  </Card>
</CardGroup>
