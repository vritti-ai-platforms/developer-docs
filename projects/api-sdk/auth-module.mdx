---
title: "Getting Started with Auth Module"
description: "Quick start guide for using @vritti/api-sdk authentication features"
---

The `@vritti/api-sdk` provides JWT authentication with guards, decorators, and utilities for securing NestJS applications.

For authentication concepts, guard behavior, and security patterns, see [Guards & Decorators](/architecture/backend/guards-decorators).

## Installation

The `@vritti/api-sdk` package includes all authentication dependencies:

```bash
npm install @vritti/api-sdk
```

## Basic Setup

### 1. Configure AuthConfigModule

Import and configure the `AuthConfigModule` in your app module:

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthConfigModule } from '@vritti/api-sdk';

@Module({
  imports: [
    ConfigModule.forRoot(),
    AuthConfigModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        secret: config.get('JWT_SECRET'),
      }),
    }),
  ],
})
export class AppModule {}
```

This automatically registers the global `VrittiAuthGuard` which protects all routes by default.

### 2. Use Decorators in Controllers

```typescript
import { Controller, Get, Post, Body } from '@nestjs/common';
import { Public, Onboarding, UserId, Tenant } from '@vritti/api-sdk';
import type { TenantInfo } from '@vritti/api-sdk';

@Controller('users')
export class UserController {
  // Public endpoint - no authentication required
  @Public()
  @Get('health')
  health() {
    return { status: 'ok' };
  }

  // Onboarding endpoint - requires onboarding token
  @Onboarding()
  @Post('verify-email')
  verifyEmail(@UserId() userId: string, @Body() dto: VerifyEmailDto) {
    return this.userService.verifyEmail(userId, dto);
  }

  // Protected endpoint - requires access token
  @Get('profile')
  getProfile(@UserId() userId: string, @Tenant() tenant: TenantInfo) {
    return this.userService.getProfile(userId, tenant.id);
  }
}
```

## Common Decorators

| Decorator | Purpose | Example Use Case |
|-----------|---------|------------------|
| `@Public()` | Bypass authentication | Health checks, public APIs |
| `@Onboarding()` | Require onboarding token | Email verification, password setup |
| `@UserId()` | Extract authenticated user ID | Get current user's data |
| `@Tenant()` | Inject tenant information | Multi-tenant operations |
| `@SkipCsrf()` | Skip CSRF validation | Webhook endpoints |

## SSE Authentication

For Server-Sent Events endpoints, use `SseAuthGuard` with token in query params:

```typescript
import { Controller, Sse, Query, UseGuards } from '@nestjs/common';
import { Public, SseAuthGuard } from '@vritti/api-sdk';

@Controller('events')
export class EventsController {
  @Public()  // Bypass global guard
  @UseGuards(SseAuthGuard)  // Use SSE-specific guard
  @Sse('stream')
  stream(@Query('token') token: string) {
    return this.eventsService.getStream();
  }
}
```

Client connects with: `GET /events/stream?token=<jwt>`

## Token Utilities

The SDK provides utilities for token hashing and verification:

```typescript
import { hashToken, verifyTokenHash } from '@vritti/api-sdk';

// Hash a token for storage
const hash = hashToken(refreshToken);
await this.sessionRepository.update(sessionId, { refreshTokenHash: hash });

// Verify a token against its hash
const isValid = verifyTokenHash(refreshToken, storedHash);
```

## CSRF Protection

CSRF validation is automatic for POST, PUT, DELETE, and PATCH requests.

**Client Flow:**
1. Fetch token: `GET /csrf/token`
2. Include in header: `x-csrf-token: <token>`

**Skip for webhooks:**
```typescript
@SkipCsrf()
@Post('webhook/stripe')
handleStripeWebhook(@Body() payload: any) {
  // External webhooks can't provide CSRF tokens
}
```

## Configuration

Configure authentication behavior using `configureApiSdk`:

```typescript
import { configureApiSdk } from '@vritti/api-sdk';

configureApiSdk({
  jwt: {
    accessTokenExpiry: '15m',
    refreshTokenExpiry: '30d',
    onboardingTokenExpiry: '24h',
    validateTokenBinding: true,
  },
  guard: {
    tenantHeaderName: 'x-tenant-id',
    authHeaderName: 'authorization',
    tokenPrefix: 'Bearer',
  },
});
```

## Quick Reference

### Token Types

The SDK uses three token types:

| Token | Lifetime | Purpose |
|-------|----------|---------|
| Access | 15 minutes | API requests |
| Refresh | 30 days | Token refresh |
| Onboarding | 24 hours | Onboarding flow |

For detailed token structures and security patterns, see [Guards & Decorators - Token Types](/architecture/backend/guards-decorators#token-types).

### Guard Behavior

| Decorator | Token Required | Tenant Validated | CSRF Checked |
|-----------|----------------|------------------|--------------|
| `@Public()` | ❌ | ❌ | ❌ |
| `@Onboarding()` | ✅ (onboarding) | ❌ | ✅ |
| None (default) | ✅ (access) | ✅ | ✅ |

## Next Steps

<CardGroup cols={2}>
  <Card title="Guards & Decorators" icon="shield" href="/architecture/backend/guards-decorators">
    Learn about authentication flow, token binding, and security patterns
  </Card>
  <Card title="Service Patterns" icon="layer-group" href="/architecture/backend/service-patterns">
    Understand how to structure services with authentication
  </Card>
  <Card title="Multi-Tenancy" icon="building" href="/architecture/backend/multi-tenancy">
    Learn about tenant context and isolation
  </Card>
  <Card title="Error Handling" icon="exclamation-triangle" href="/architecture/backend/guards-decorators#error-handling">
    See authentication error responses
  </Card>
</CardGroup>
