---
title: "Multi-Factor Authentication (MFA)"
description: "TOTP, SMS, and Passkey-based multi-factor authentication"
---

## Overview

<Info>
**Implemented by:** Sunvish
**Last Updated:** January 2026
**Status:** Production
</Info>

MFA adds an additional layer of security by requiring users to verify their identity using a second factor after password authentication. Supported methods include TOTP (authenticator apps), SMS OTP, and Passkeys.

## What It Does

- Generates TOTP secrets with QR codes for authenticator apps
- Sends SMS OTP codes to verified phone numbers
- Supports passkey-based MFA verification
- Generates 10 one-time backup/recovery codes
- Validates codes with clock drift tolerance (±30 seconds)
- Tracks and removes used backup codes

## Where It's Used

| Location | Purpose |
|----------|---------|
| `vritti-api-nexus/src/modules/cloud-api/onboarding/controllers/two-factor.controller.ts` | MFA setup endpoints |
| `vritti-api-nexus/src/modules/cloud-api/onboarding/services/two-factor-auth.service.ts` | Setup flow logic |
| `vritti-api-nexus/src/modules/cloud-api/onboarding/services/totp.service.ts` | TOTP generation/validation |
| `vritti-api-nexus/src/modules/cloud-api/auth/mfa-verification/` | MFA verification during login |
| `vritti-api-nexus/src/modules/cloud-api/auth/services/auth.service.ts` | Login flow with MFA check |
| `vritti-auth/src/pages/onboarding/MFASetupFlowPage.tsx` | Setup UI flow |
| `vritti-auth/src/pages/auth/MFAVerificationPage.tsx` | Verification UI |
| `vritti-auth/src/components/onboarding/mfa/` | Setup components |
| `vritti-auth/src/components/auth/mfa-verification/` | Verification components |

## Architecture

### MFA Setup Flow (Onboarding)

<Steps>
  <Step title="Choose Method">
    User selects between Authenticator App (TOTP) or Passkey.

    ```typescript
    // Frontend - MFAMethodSelection.tsx
    <MFAMethodSelection
      selectedMethod={selectedMethod}
      onSelect={handleMethodSelect}
      onContinue={handleContinue}
      onSkip={handleSkip}
    />
    ```
  </Step>

  <Step title="TOTP Setup">
    For authenticator apps, generate secret and display QR code.

    ```typescript
    // vritti-api-nexus - totp.service.ts
    generateTotpSecret(): string {
      return authenticator.generateSecret(20);  // 20-byte secret
    }

    generateKeyUri(accountName: string, secret: string): string {
      return authenticator.keyuri(accountName, 'Vritti', secret);
    }

    async generateQrCodeDataUrl(keyUri: string): Promise<string> {
      return await QRCode.toDataURL(keyUri, {
        width: 200,
        margin: 2,
      });
    }
    ```
  </Step>

  <Step title="Verify Code">
    User enters 6-digit code from authenticator app.

    ```typescript
    // vritti-api-nexus - totp.service.ts
    verifyToken(token: string, secret: string): boolean {
      return authenticator.verify({ token, secret });
    }
    ```
  </Step>

  <Step title="Generate Backup Codes">
    On successful verification, generate and display recovery codes.

    ```typescript
    // vritti-api-nexus - totp.service.ts
    generateBackupCodes(): string[] {
      const codes: string[] = [];
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';  // No confusing chars

      for (let i = 0; i < 10; i++) {
        let code = '';
        for (let j = 0; j < 8; j++) {
          code += chars[Math.floor(Math.random() * chars.length)];
        }
        codes.push(code);
      }
      return codes;
    }
    ```
  </Step>
</Steps>

### MFA Verification Flow (Login)

<Steps>
  <Step title="Password Verification">
    User logs in with email/password. If MFA enabled, return challenge.

    ```typescript
    // vritti-api-nexus - auth.service.ts
    async login(dto: LoginDto, ipAddress?, userAgent?) {
      // Verify password...

      // Check for MFA
      const mfaChallenge = await this.mfaVerificationService.createMfaChallenge(user, {
        ipAddress,
        userAgent,
      });

      if (mfaChallenge) {
        return new AuthResponseDto({
          requiresMfa: true,
          mfaChallenge: {
            sessionId: mfaChallenge.sessionId,
            availableMethods: mfaChallenge.availableMethods,
            defaultMethod: mfaChallenge.defaultMethod,
            maskedPhone: mfaChallenge.maskedPhone,
          },
        });
      }

      // No MFA - return tokens
      return { accessToken, refreshToken };
    }
    ```
  </Step>

  <Step title="MFA Challenge">
    Frontend displays MFA verification page with available methods.

    ```typescript
    // vritti-auth - MFAVerificationPage.tsx
    <MFAVerificationPage>
      {activeMethod === 'totp' && <TOTPVerification />}
      {activeMethod === 'sms' && <SMSVerification />}
      {activeMethod === 'passkey' && <PasskeyVerification />}
      <MethodSwitcher availableMethods={challenge.availableMethods} />
    </MFAVerificationPage>
    ```
  </Step>

  <Step title="Verify Factor">
    Backend validates the MFA code/credential.

    ```typescript
    // vritti-api-nexus - mfa-verification.service.ts
    async verifyTotp(sessionId: string, code: string) {
      const challenge = this.getMfaChallengeOrThrow(sessionId);
      const twoFactorAuth = await this.twoFactorAuthRepo.findByUserIdAndMethod(
        challenge.userId,
        'TOTP',
      );

      const isValid = this.totpService.verifyToken(code, twoFactorAuth.totpSecret);

      if (!isValid) {
        // Try backup code
        const backupResult = await this.tryBackupCode(code, twoFactorAuth);
        if (!backupResult.valid) {
          throw new BadRequestException('Invalid verification code');
        }
      }

      return this.completeMfaVerification(challenge);
    }
    ```
  </Step>

  <Step title="Complete Login">
    On successful MFA, create session and return tokens.

    ```typescript
    // vritti-api-nexus - mfa-verification.service.ts
    private async completeMfaVerification(challenge: MfaChallenge) {
      const { accessToken, expiresIn } = await this.sessionService.createUnifiedSession(
        challenge.userId,
        'CLOUD',
        challenge.ipAddress,
        challenge.userAgent,
      );

      this.mfaChallengeStore.delete(challenge.sessionId);

      return new MfaVerificationResponseDto({
        accessToken,
        expiresIn,
        tokenType: 'Bearer',
        user: { id, email, firstName, lastName },
      });
    }
    ```
  </Step>
</Steps>

## MFA Challenge Store

```typescript
// vritti-api-nexus - mfa-challenge.store.ts
export interface MfaChallenge {
  sessionId: string;
  userId: string;
  availableMethods: MfaMethod[];  // ['totp', 'sms', 'passkey']
  defaultMethod: MfaMethod;
  maskedPhone?: string;           // "+91 *** ***1234"
  passkeyChallenge?: string;      // For passkey verification
  smsOtpHash?: string;            // Hashed SMS OTP
  expiresAt: Date;                // 5-minute TTL
  ipAddress?: string;
  userAgent?: string;
}

@Injectable()
export class MfaChallengeStore {
  private readonly challenges = new Map<string, MfaChallenge>();
  private readonly MFA_CHALLENGE_TTL_MINUTES = 5;

  create(userId: string, availableMethods: MfaMethod[], options): MfaChallenge {
    const sessionId = crypto.randomUUID();
    // Determine default: TOTP > SMS > Passkey
    const defaultMethod = availableMethods.includes('totp') ? 'totp' :
                          availableMethods.includes('sms') ? 'sms' : 'passkey';

    const challenge = { sessionId, userId, availableMethods, defaultMethod, ... };
    this.challenges.set(sessionId, challenge);
    this.scheduleCleanup(sessionId);
    return challenge;
  }
}
```

## Database Schema

```typescript
// vritti-api-nexus/src/db/schema/verification.ts
export const twoFactorAuth = cloudSchema.table('two_factor_auth', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id),
  method: twoFactorMethodEnum('method').notNull(),  // 'TOTP' | 'PASSKEY'
  isActive: boolean('is_active').notNull().default(true),

  // TOTP-specific fields
  totpSecret: varchar('totp_secret', { length: 255 }),
  totpBackupCodes: text('totp_backup_codes'),  // JSON array of bcrypt hashes

  // Passkey-specific fields
  passkeyCredentialId: varchar('passkey_credential_id', { length: 255 }).unique(),
  passkeyPublicKey: text('passkey_public_key'),
  passkeyCounter: integer('passkey_counter'),
  passkeyTransports: varchar('passkey_transports', { length: 255 }),

  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
  lastUsedAt: timestamp('last_used_at'),
});
```

## TOTP Configuration

```typescript
// vritti-api-nexus - totp.service.ts
constructor() {
  authenticator.options = {
    digits: 6,      // 6-digit codes
    step: 30,       // 30-second window
    window: 1,      // Allow ±1 step for clock drift
  };
}
```

## API Endpoints

### Setup (Onboarding)
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/onboarding/2fa/totp/setup` | Get QR code and secret |
| POST | `/onboarding/2fa/totp/verify` | Verify code and enable |
| POST | `/onboarding/2fa/passkey/setup` | Get passkey options |
| POST | `/onboarding/2fa/passkey/verify` | Register passkey |
| POST | `/onboarding/2fa/skip` | Skip MFA setup |
| GET | `/onboarding/2fa/status` | Get MFA status |

### Verification (Login)
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/auth/mfa/verify-totp` | Verify TOTP code |
| POST | `/auth/mfa/sms/send` | Send SMS OTP |
| POST | `/auth/mfa/sms/verify` | Verify SMS OTP |
| POST | `/auth/mfa/passkey/start` | Start passkey MFA |
| POST | `/auth/mfa/passkey/verify` | Verify passkey MFA |

## Backup Codes

### Generation
- 10 codes generated per MFA setup
- 8 characters each (A-Z, 2-9, excluding confusing chars)
- Hashed with bcrypt before storage
- Displayed only once to user

### Verification
```typescript
// vritti-api-nexus - totp.service.ts
async verifyBackupCode(code: string, hashedCodes: string[]) {
  for (let i = 0; i < hashedCodes.length; i++) {
    const isMatch = await this.encryptionService.compareOtp(
      code.toUpperCase(),
      hashedCodes[i],
    );
    if (isMatch) {
      // Remove used code
      const remainingHashes = [...hashedCodes.slice(0, i), ...hashedCodes.slice(i + 1)];
      return { valid: true, remainingHashes };
    }
  }
  return { valid: false, remainingHashes: hashedCodes };
}
```

## Frontend Components

### TOTP Setup (QR Code Display)
```typescript
// vritti-auth - AuthenticatorSetup.tsx
<div className="w-[200px] h-[200px] bg-white">
  <img src={totpData.qrCodeDataUrl} alt="Scan QR code" />
</div>

<div className="font-mono">
  {totpData.manualSetupKey}  {/* XXXX XXXX XXXX XXXX */}
</div>

<OTPField name="code" onChange={handleVerify} />
```

### Backup Codes Display
```typescript
// vritti-auth - BackupCodesDisplay.tsx
<div className="grid grid-cols-2 gap-2">
  {backupCodes.map((code, index) => (
    <div className="font-mono text-center select-all">
      {code}
    </div>
  ))}
</div>

<Button onClick={handleCopyAll}>
  Copy all codes
</Button>
```

### MFA Verification Page
```typescript
// vritti-auth - MFAVerificationPage.tsx
const handleMFASuccess = (response) => {
  if (response.accessToken) {
    setToken(response.accessToken);
    scheduleTokenRefresh(response.expiresIn);
  }
  navigate('/dashboard');
};
```

## Security Features

1. **TOTP Security**
   - 6-digit codes with 30-second validity
   - ±30 second tolerance for clock drift
   - Secrets stored server-side only

2. **Backup Codes**
   - Bcrypt-hashed storage
   - One-time use (removed after verification)
   - 10 codes provide recovery options

3. **Challenge Expiry**
   - MFA challenges expire after 5 minutes
   - Automatic cleanup prevents stale sessions

4. **Method Flexibility**
   - Multiple methods available per user
   - Fallback to SMS if TOTP unavailable
   - Phone must be verified for SMS

## Limitations

<Warning>
**Known Limitations:**
</Warning>

1. **Session Storage**: MFA challenges use in-memory Map; consider Redis for distributed systems
2. **SMS Dependency**: SMS OTP requires verified phone number
3. **Method Priority**: Default order is TOTP > SMS > Passkey (hardcoded)
4. **Single Active Method**: Only one primary 2FA method active at a time

## Troubleshooting

<Accordion title="Invalid verification code">
  **Causes:**
  - Clock drift between device and server
  - Code expired (>30 seconds old)
  - Typo in manual entry

  **Solution:**
  1. Ensure device time is synchronized
  2. Wait for new code and enter quickly
  3. Try backup code if persistent
</Accordion>

<Accordion title="QR code not scanning">
  **Cause:** Camera focus or lighting issues

  **Solution:**
  1. Use manual setup key instead
  2. Enter: Account = email, Issuer = Vritti
  3. Copy secret key from display
</Accordion>

<Accordion title="SMS code not received">
  **Causes:**
  - Carrier delays
  - Phone number not verified
  - Rate limiting

  **Solution:**
  1. Wait 30 seconds and resend
  2. Check phone verification status
  3. Use TOTP or passkey instead
</Accordion>

<Accordion title="All backup codes used">
  **Cause:** No remaining recovery codes

  **Solution:**
  User must contact support to disable MFA or generate new backup codes (requires identity verification).
</Accordion>

## Related Concepts

- **Passkeys** - Can be used as MFA factor
- **Session Management** - MFA creates standard session tokens
- **Phone Verification** - Required for SMS MFA
- **Onboarding Flow** - MFA setup is part of user onboarding
