---
title: "Apple OAuth"
description: "Sign in with Apple integration using JWT client secret"
---

## Overview

<Info>
**Implemented in:** vritti-api-nexus
**Last Updated:** January 2026
**Status:** Production
</Info>

Sign in with Apple allows users to authenticate using their Apple ID. The implementation uses OAuth 2.0 with a unique JWT-based client secret (signed with ES256) and decodes user information from the ID token.

## What It Does

- Authenticates users via Apple ID
- Uses ES256-signed JWT as client secret
- Decodes user info from ID token (no user info endpoint)
- Supports PKCE with S256 challenge method
- Receives callback via form_post response mode

## Where It's Used

| Location | Purpose |
|----------|---------|
| `vritti-api-nexus/src/modules/cloud-api/auth/oauth/apple-oauth.provider.ts` | Apple OAuth provider |
| `vritti-auth/src/pages/login/` | "Sign in with Apple" button |

## Configuration

### Apple Developer Setup

1. Go to [Apple Developer Portal](https://developer.apple.com/)
2. Navigate to **Certificates, Identifiers & Profiles**
3. Create a new **App ID** (if not exists)
4. Create a **Services ID** for Sign in with Apple
5. Configure Sign in with Apple for the Services ID
6. Create a **Key** for Sign in with Apple
7. Download the private key (.p8 file)

### Required Values

| Value | Where to Find |
|-------|---------------|
| Client ID | Services ID identifier (e.g., `com.vritti.auth`) |
| Team ID | Found in Membership section |
| Key ID | From the key you created |
| Private Key | Downloaded .p8 file contents |

### Callback URLs

| Environment | Callback URL |
|-------------|--------------|
| Local | `http://localhost:3000/cloud-api/auth/oauth/apple/callback` |
| Staging | `https://api-staging.vritti.app/cloud-api/auth/oauth/apple/callback` |
| Production | `https://api.vritti.app/cloud-api/auth/oauth/apple/callback` |

### Environment Variables

```bash
# Apple OAuth credentials
APPLE_CLIENT_ID=com.vritti.auth
APPLE_TEAM_ID=ABC123DEF4
APPLE_KEY_ID=XYZ789KEY1
APPLE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\nMIGT...\n-----END PRIVATE KEY-----"
APPLE_CALLBACK_URL=https://api.vritti.app/cloud-api/auth/oauth/apple/callback
```

<Warning>
The private key must be stored securely. Use environment variables or secrets management. Never commit the key to version control.
</Warning>

## OAuth Scopes

| Scope | Purpose |
|-------|---------|
| `name` | User's name (only on first authorization) |
| `email` | User's email address |

## Implementation

### Provider Configuration

```typescript
// apple-oauth.provider.ts
@Injectable()
export class AppleOAuthProvider implements IOAuthProvider {
  private readonly AUTHORIZATION_URL = 'https://appleid.apple.com/auth/authorize';
  private readonly TOKEN_URL = 'https://appleid.apple.com/auth/token';

  constructor(
    private readonly configService: ConfigService,
    private readonly jwtService: JwtService,
  ) {
    this.clientId = this.configService.getOrThrow<string>('APPLE_CLIENT_ID');
    this.teamId = this.configService.getOrThrow<string>('APPLE_TEAM_ID');
    this.keyId = this.configService.getOrThrow<string>('APPLE_KEY_ID');
    this.privateKey = this.configService.getOrThrow<string>('APPLE_PRIVATE_KEY');
    this.redirectUri = this.configService.getOrThrow<string>('APPLE_CALLBACK_URL');
  }
}
```

### Authorization URL

```typescript
getAuthorizationUrl(state: string, codeChallenge?: string): string {
  const params = new URLSearchParams({
    client_id: this.clientId,
    redirect_uri: this.redirectUri,
    response_type: 'code',
    scope: 'name email',
    response_mode: 'form_post',  // Apple recommends form_post
    state,
  });

  // Add PKCE if code challenge provided
  if (codeChallenge) {
    params.append('code_challenge', codeChallenge);
    params.append('code_challenge_method', 'S256');
  }

  return `${this.AUTHORIZATION_URL}?${params.toString()}`;
}
```

### JWT Client Secret Generation

Apple requires a JWT signed with ES256 instead of a static client secret:

```typescript
private generateClientSecret(): string {
  const now = Math.floor(Date.now() / 1000);

  // Create JWT header
  const header = {
    alg: 'ES256',
    kid: this.keyId,
  };

  // Create JWT payload
  const payload = {
    iss: this.teamId,
    iat: now,
    exp: now + 15777000,  // 6 months (max allowed)
    aud: 'https://appleid.apple.com',
    sub: this.clientId,
  };

  // Base64URL encode and sign
  const headerB64 = this.base64URLEncode(JSON.stringify(header));
  const payloadB64 = this.base64URLEncode(JSON.stringify(payload));
  const token = `${headerB64}.${payloadB64}`;

  // Sign with ES256 (ECDSA with SHA-256)
  const sign = crypto.createSign('SHA256');
  sign.update(token);
  sign.end();

  const signature = sign.sign(this.privateKey, 'base64');
  const signatureB64 = this.base64URLEncode(Buffer.from(signature, 'base64'));

  return `${token}.${signatureB64}`;
}
```

### Token Exchange

```typescript
async exchangeCodeForToken(code: string, codeVerifier?: string): Promise<OAuthTokens> {
  // Generate client secret JWT
  const clientSecret = this.generateClientSecret();

  const data = {
    code,
    client_id: this.clientId,
    client_secret: clientSecret,
    redirect_uri: this.redirectUri,
    grant_type: 'authorization_code',
    code_verifier: codeVerifier,
  };

  const response = await axios.post(this.TOKEN_URL, data, {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  });

  return {
    accessToken: response.data.access_token,
    refreshToken: response.data.refresh_token,
    tokenType: response.data.token_type,
    expiresIn: response.data.expires_in,
    idToken: response.data.id_token,
  };
}
```

### User Profile from ID Token

Apple doesn't have a user info endpoint. User data is decoded from the ID token:

```typescript
async getUserProfile(accessToken: string): Promise<OAuthUserProfile> {
  // Decode the ID token (passed as accessToken)
  const decoded = this.jwtService.decode(accessToken) as AppleIdTokenPayload;

  if (!decoded) {
    throw new Error('Failed to decode Apple ID token');
  }

  if (!decoded.email) {
    throw new Error('Apple ID token missing email');
  }

  return {
    provider: 'APPLE',
    providerId: decoded.sub,
    email: decoded.email,
    displayName: decoded.email,  // Name only provided on first auth
    firstName: undefined,
    lastName: undefined,
    profilePictureUrl: undefined,
  };
}
```

## Authentication Flow

```mermaid
sequenceDiagram
    participant User
    participant App
    participant API
    participant Apple

    User->>App: Click "Sign in with Apple"
    App->>API: GET /oauth/apple/initiate
    API->>API: Generate PKCE verifier + challenge
    API-->>App: Authorization URL

    App->>Apple: Redirect to consent screen
    User->>Apple: Enter Apple ID, grant consent
    Apple->>API: POST callback (form_post) with code + state

    API->>API: Generate JWT client secret
    API->>Apple: POST /token (code + JWT secret)
    Apple-->>API: Access token + ID token

    API->>API: Decode ID token for user info
    API->>API: Create/update user
    API-->>App: Set cookies, redirect
```

## Response Data

### Token Response

```json
{
  "access_token": "a1b2c3d4...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "r1a2b3c4...",
  "id_token": "eyJraWQiOiJXNldjT0..."
}
```

### Decoded ID Token

```json
{
  "iss": "https://appleid.apple.com",
  "aud": "com.vritti.auth",
  "exp": 1706350200,
  "iat": 1706263800,
  "sub": "001234.abcd5678efgh.1234",
  "email": "user@privaterelay.appleid.com",
  "email_verified": "true",
  "is_private_email": "true",
  "auth_time": 1706263800
}
```

## Important Behaviors

### Name Only on First Authorization

<Note>
Apple only provides the user's name on the **first** authorization. Store it immediately as it won't be available on subsequent logins.
</Note>

The first authorization includes a `user` object in the form post:

```json
{
  "user": {
    "name": {
      "firstName": "John",
      "lastName": "Doe"
    },
    "email": "user@example.com"
  }
}
```

### Private Email Relay

Users can choose to hide their real email. Apple provides a relay email:

```
user@privaterelay.appleid.com
```

This email forwards to the user's real email address.

### Form Post Response Mode

Apple uses `response_mode=form_post`, meaning the callback is a POST request with form data, not a GET request with query parameters.

## Error Handling

| Error | Cause | Resolution |
|-------|-------|------------|
| `invalid_client` | JWT client secret issue | Check Team ID, Key ID, Private Key |
| `invalid_grant` | Code expired or used | Restart OAuth flow |
| `user_cancelled_authorize` | User cancelled | Show retry option |

### Error Response Example

```json
{
  "error": "invalid_client",
  "error_description": "The client_secret is invalid."
}
```

## Security Best Practices

<CardGroup cols={2}>
  <Card title="Private Key Security" icon="key">
    Store private key in secrets manager
  </Card>
  <Card title="JWT Expiration" icon="clock">
    Client secret JWT valid for 6 months max
  </Card>
  <Card title="ID Token Validation" icon="shield">
    Verify ID token signature and claims
  </Card>
  <Card title="Form Post Handling" icon="envelope">
    Handle POST callback correctly
  </Card>
</CardGroup>

## Troubleshooting

<Accordion title="Error: invalid_client">
  **Cause:** JWT client secret is malformed

  **Solution:**
  - Verify Team ID matches your Apple Developer account
  - Check Key ID matches the key you created
  - Ensure private key is properly formatted with newlines
  - Verify ES256 signature algorithm is used
</Accordion>

<Accordion title="Error: redirect_uri_mismatch">
  **Cause:** Callback URL not configured

  **Solution:**
  - Add exact URL in Apple Developer Portal
  - Configure URL in Services ID settings
  - Check for http vs https
</Accordion>

<Accordion title="Missing email in ID token">
  **Cause:** User opted for private relay without sharing

  **Solution:**
  - Email is optional for private relay users
  - Handle missing email gracefully
  - Prompt user to provide email manually
</Accordion>

<Accordion title="Name not returned on login">
  **Cause:** Name is only provided on first authorization

  **Solution:**
  - Store name immediately on first auth
  - Cannot retrieve name on subsequent logins
  - Apple designed this for privacy
</Accordion>

## Related Documentation

<CardGroup cols={2}>
  <Card title="OAuth Overview" icon="key" href="/features/oauth/overview">
    OAuth architecture and PKCE
  </Card>
  <Card title="Google OAuth" icon="google" href="/features/oauth/google">
    Google OAuth setup
  </Card>
  <Card title="Microsoft OAuth" icon="microsoft" href="/features/oauth/microsoft">
    Microsoft OAuth setup
  </Card>
  <Card title="Facebook OAuth" icon="facebook" href="/features/oauth/facebook">
    Facebook OAuth setup
  </Card>
</CardGroup>
