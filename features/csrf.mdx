---
title: "CSRF Protection"
description: "Cross-Site Request Forgery protection using Fastify and NestJS Guards"
---

## Overview

<Info>
**Implemented by:** Shashank
**Last Updated:** January 2026
**Status:** Production
</Info>

CSRF (Cross-Site Request Forgery) protection prevents unauthorized commands from being transmitted from a user that the web application trusts. Our implementation uses `@fastify/csrf-protection` with a custom NestJS guard.

## What It Does

- Generates HMAC-signed tokens using a secret key
- Stores token secret in signed, httpOnly cookies (`_csrf`)
- Validates tokens on state-changing requests (POST, PUT, PATCH, DELETE)
- Automatically skips safe methods (GET, HEAD, OPTIONS)
- Integrates with OAuth flow for state token signing

## Where It's Used

| Location | Purpose |
|----------|---------|
| `vritti-api-nexus/src/csrf.controller.ts` | Token generation endpoint |
| `api-sdk/src/http/guards/csrf.guard.ts` | Global CSRF validation guard |
| `vritti-api-nexus/src/main.ts` | Fastify plugin registration |
| `vritti-auth/src/utils/csrfToken.ts` | Frontend token management |
| `api-sdk/src/http/http.module.ts` | Guard module export |

## Architecture

### Token Flow

<Steps>
  <Step title="Get CSRF Token">
    Frontend calls `GET /csrf/token` to obtain a token. This endpoint is marked `@Public()` so it doesn't require authentication.

    ```typescript
    // vritti-api-nexus/src/csrf.controller.ts
    @Controller('csrf')
    export class CsrfController {
      @Get('token')
      @Public()
      @HttpCode(HttpStatus.OK)
      getToken(@Res({ passthrough: true }) reply: FastifyReply): { csrfToken: string } {
        const csrfToken = reply.generateCsrf();
        return { csrfToken };
      }
    }
    ```
  </Step>

  <Step title="Store & Send Token">
    Frontend stores the token and includes it in the `X-CSRF-Token` header for all state-changing requests.

    ```typescript
    // vritti-auth/src/utils/csrfToken.ts
    axios.interceptors.request.use(async (config) => {
      const method = config.method?.toUpperCase();
      if (CSRF_PROTECTED_METHODS.includes(method)) {
        const token = await getCsrfToken();
        config.headers['X-CSRF-Token'] = token;
      }
      return config;
    });
    ```
  </Step>

  <Step title="Validate Token">
    The `CsrfGuard` validates the token on every state-changing request.

    ```typescript
    // api-sdk/src/http/guards/csrf.guard.ts
    @Injectable()
    export class CsrfGuard implements CanActivate {
      async canActivate(context: ExecutionContext): Promise<boolean> {
        const request = context.switchToHttp().getRequest<FastifyRequest>();

        // Skip safe methods
        if (['GET', 'HEAD', 'OPTIONS'].includes(request.method)) {
          return true;
        }

        // Validate using Fastify's csrfProtection
        await fastifyInstance.csrfProtection(request, reply, callback);
        return true;
      }
    }
    ```
  </Step>
</Steps>

## Configuration

### Fastify Plugin Setup

```typescript
// vritti-api-nexus/src/main.ts
import fastifyCookie from '@fastify/cookie';
import fastifyCsrfProtection from '@fastify/csrf-protection';

async function bootstrap() {
  // Cookie support (required for CSRF)
  await app.register(fastifyCookie, {
    secret: configService.getOrThrow<string>('COOKIE_SECRET'),
  });

  // CSRF protection
  await app.register(fastifyCsrfProtection, {
    cookieOpts: {
      signed: true,
      httpOnly: true,
      sameSite: 'lax',  // 'strict' breaks OAuth redirects
      secure: process.env.NODE_ENV === 'production',
      path: '/',
    },
    csrfOpts: {
      hmacKey: configService.getOrThrow<string>('CSRF_HMAC_KEY'),
    },
  });

  // CORS with CSRF header support
  app.enableCors({
    origin: [...allowedOrigins],
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization', 'X-CSRF-Token'],
  });
}
```

### Environment Variables

```bash
# .env
COOKIE_SECRET=your-cookie-signing-secret
CSRF_HMAC_KEY=your-64-byte-hex-hmac-key
```

## The CSRF Guard

### Implementation

```typescript
// api-sdk/src/http/guards/csrf.guard.ts
@Injectable()
export class CsrfGuard implements CanActivate {
  private readonly logger = new Logger(CsrfGuard.name);

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<FastifyRequest>();
    const reply = context.switchToHttp().getResponse<FastifyReply>();

    // Skip safe methods
    const safeMethods = ['GET', 'HEAD', 'OPTIONS'];
    if (safeMethods.includes(request.method)) {
      return true;
    }

    try {
      const fastifyInstance = request.server as any;

      if (!fastifyInstance.csrfProtection) {
        throw new ForbiddenException('CSRF protection not configured');
      }

      await new Promise<void>((resolve, reject) => {
        fastifyInstance.csrfProtection(request, reply, (err?: Error) => {
          if (err) reject(err);
          else resolve();
        });
      });

      return true;
    } catch (error) {
      throw new ForbiddenException({
        errors: [{ field: 'csrf', message: 'Invalid or missing CSRF token' }],
        message: 'CSRF validation failed',
      });
    }
  }
}
```

### Accepted Token Sources

The guard accepts tokens from these locations (in priority order):

1. `req.headers['csrf-token']`
2. `req.headers['xsrf-token']`
3. `req.headers['x-csrf-token']`
4. `req.headers['x-xsrf-token']`
5. `req.body._csrf`

### Module Export

```typescript
// api-sdk/src/http/http.module.ts
@Module({
  providers: [CsrfGuard],
  exports: [CsrfGuard],
})
export class HttpModule {}
```

## Frontend Integration

### Token Management

```typescript
// vritti-auth/src/utils/csrfToken.ts
let csrfToken: string | null = null;

export async function refreshCsrfToken(): Promise<string> {
  const response = await axios.get<{ token: string }>('/csrf/token', {
    withCredentials: true,
  });
  csrfToken = response.data.token;
  return csrfToken;
}

export async function initializeCsrf(): Promise<void> {
  await refreshCsrfToken();

  // Request interceptor: Add token to protected requests
  axios.interceptors.request.use(async (config) => {
    const method = config.method?.toUpperCase();
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(method)) {
      config.headers['X-CSRF-Token'] = await getCsrfToken();
    }
    return config;
  });

  // Response interceptor: Auto-refresh on 403 CSRF errors
  axios.interceptors.response.use(
    (response) => response,
    async (error) => {
      if (isCsrfError(error) && !error.config._csrfRetry) {
        error.config._csrfRetry = true;
        const newToken = await refreshCsrfToken();
        error.config.headers['X-CSRF-Token'] = newToken;
        return axios(error.config);
      }
      return Promise.reject(error);
    }
  );
}
```

## OAuth State Protection

CSRF protection extends to OAuth flows via signed state tokens:

```typescript
// vritti-api-nexus/src/modules/cloud-api/auth/oauth/services/oauth-state.service.ts
@Injectable()
export class OAuthStateService {
  constructor(private readonly configService: ConfigService) {
    this.hmacSecret = this.configService.getOrThrow<string>('CSRF_HMAC_KEY');
  }

  async generateState(provider: OAuthProviderType, userId: string | undefined, codeVerifier: string): Promise<string> {
    const stateToken = crypto.randomBytes(32).toString('hex');
    const signedStateToken = this.signStateToken(stateToken);  // Uses CSRF_HMAC_KEY
    // ... store in database with expiry
    return signedStateToken;
  }
}
```

## Bypassing CSRF (Public Endpoints)

Use the `@Public()` decorator to bypass both authentication and CSRF validation:

```typescript
import { Public } from '@vritti/api-sdk';

@Controller('health')
export class HealthController {
  @Get()
  @Public()  // No auth, no CSRF
  check() {
    return { status: 'ok' };
  }
}
```

## Limitations

<Warning>
**Known Limitations:**
</Warning>

1. **Cookie Dependency**: Requires cookies to be enabled; won't work with cookie-blocking browsers
2. **SameSite Lax**: Uses `sameSite: 'lax'` instead of `strict` to support OAuth redirects
3. **Single Domain**: Tokens are tied to the cookie domain; cross-domain requests need separate handling
4. **Token Refresh**: Tokens don't auto-refresh; frontend must handle 403 errors

## Troubleshooting

<Accordion title="403 Forbidden: CSRF validation failed">
  **Causes:**
  - Token not included in `X-CSRF-Token` header
  - Cookie `_csrf` missing or expired
  - Token mismatch (stale token)

  **Solution:**
  1. Ensure `withCredentials: true` in axios config
  2. Check if `_csrf` cookie exists in browser DevTools
  3. Call `/csrf/token` to get a fresh token
  4. Verify CORS allows `X-CSRF-Token` header
</Accordion>

<Accordion title="CSRF protection plugin not found">
  **Cause:** `@fastify/csrf-protection` not registered in main.ts

  **Solution:** Ensure plugin registration order:
  ```typescript
  await app.register(fastifyCookie, {...});      // 1. Cookies first
  await app.register(fastifyCsrfProtection, {...}); // 2. CSRF second
  ```
</Accordion>

<Accordion title="Token works locally but fails in production">
  **Cause:** Cookie secure flag mismatch

  **Solution:** Ensure `secure: true` only in production:
  ```typescript
  cookieOpts: {
    secure: process.env.NODE_ENV === 'production',
  }
  ```
</Accordion>

<Accordion title="OAuth redirects fail with CSRF error">
  **Cause:** `sameSite: 'strict'` blocks cookies on redirects

  **Solution:** Use `sameSite: 'lax'` for OAuth compatibility:
  ```typescript
  cookieOpts: {
    sameSite: 'lax',  // NOT 'strict'
  }
  ```
</Accordion>

## Related Concepts

- **VrittiAuthGuard** - JWT authentication guard (works alongside CSRF)
- **@Public() Decorator** - Bypasses both auth and CSRF checks
- **OAuth State Tokens** - Uses same HMAC key for state signing
- **@fastify/cookie** - Required dependency for CSRF cookie storage
