---
title: State Management
description: TanStack Query and React Context patterns for state management
---

Vritti uses TanStack Query for server state and React Context for client state. This approach separates concerns and provides optimal caching and synchronization.

## State Categories

| Type | Tool | Examples |
|------|------|----------|
| **Server State** | TanStack Query | User data, API responses, lists |
| **Client State** | React Context | Theme, auth status, UI state |
| **Form State** | React Hook Form | Form values, validation |
| **URL State** | React Router | Filters, pagination, tabs |

## TanStack Query Setup

### Query Client Configuration

```typescript
// App.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,  // 5 minutes
      retry: 1,
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 0,
    },
  },
});

export const App = () => (
  <QueryClientProvider client={queryClient}>
    <BrowserRouter>
      <AppRoutes />
    </BrowserRouter>
  </QueryClientProvider>
);
```

## Query Patterns

### Basic Query

```typescript
import { useQuery } from '@tanstack/react-query';

export const useUser = (userId: string) => {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    enabled: !!userId,  // Don't run if no userId
  });
};

// Usage
const UserProfile = ({ userId }: { userId: string }) => {
  const { data: user, isLoading, error } = useUser(userId);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return <ProfileCard user={user} />;
};
```

### Query with Options

```typescript
import { useQuery, type UseQueryOptions } from '@tanstack/react-query';

type UseUserOptions = Omit<
  UseQueryOptions<User, Error>,
  'queryKey' | 'queryFn'
>;

export const useUser = (userId: string, options?: UseUserOptions) => {
  return useQuery<User, Error>({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 10 * 60 * 1000,  // 10 minutes
    ...options,
  });
};

// Usage with custom options
const { data } = useUser(userId, {
  enabled: isAuthenticated,
  onSuccess: (user) => trackUserView(user.id),
});
```

### List Query with Pagination

```typescript
export const useUsers = (page: number, limit: number) => {
  return useQuery({
    queryKey: ['users', 'list', { page, limit }],
    queryFn: () => fetchUsers({ page, limit }),
    placeholderData: keepPreviousData,  // Keep old data while fetching
  });
};

// Usage
const UserList = () => {
  const [page, setPage] = useState(1);
  const { data, isLoading, isFetching } = useUsers(page, 10);

  return (
    <>
      {isLoading ? (
        <LoadingSpinner />
      ) : (
        <ul>
          {data?.users.map(user => (
            <UserItem key={user.id} user={user} />
          ))}
        </ul>
      )}

      <Pagination
        page={page}
        totalPages={data?.totalPages}
        onPageChange={setPage}
        isLoading={isFetching}
      />
    </>
  );
};
```

## Mutation Patterns

### Basic Mutation Hook

```typescript
import { useMutation, type UseMutationOptions } from '@tanstack/react-query';

type UseLoginOptions = Omit<
  UseMutationOptions<LoginResponse, Error, LoginDto>,
  'mutationFn'
>;

export const useLogin = (options?: UseLoginOptions) => {
  return useMutation<LoginResponse, Error, LoginDto>({
    mutationFn: (data: LoginDto) => authService.login(data),
    ...options,
  });
};
```

### Mutation with Cache Update

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';

export const useUpdateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: UpdateUserDto) => userService.update(data),
    onSuccess: (updatedUser) => {
      // Update the user in cache
      queryClient.setQueryData(['user', updatedUser.id], updatedUser);

      // Invalidate lists that might contain this user
      queryClient.invalidateQueries({ queryKey: ['users', 'list'] });
    },
  });
};
```

### Optimistic Updates

```typescript
export const useToggleFavorite = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (itemId: string) => api.toggleFavorite(itemId),

    // Optimistically update before server response
    onMutate: async (itemId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['item', itemId] });

      // Snapshot previous value
      const previousItem = queryClient.getQueryData(['item', itemId]);

      // Optimistically update
      queryClient.setQueryData(['item', itemId], (old: Item) => ({
        ...old,
        isFavorite: !old.isFavorite,
      }));

      // Return context for rollback
      return { previousItem };
    },

    // Rollback on error
    onError: (err, itemId, context) => {
      queryClient.setQueryData(['item', itemId], context?.previousItem);
    },

    // Refetch after success or error
    onSettled: (data, error, itemId) => {
      queryClient.invalidateQueries({ queryKey: ['item', itemId] });
    },
  });
};
```

## React Context Patterns

### Authentication Context

```typescript
// context/AuthContext.tsx
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (credentials: LoginDto) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for existing session on mount
    recoverSession().then(setUser).finally(() => setIsLoading(false));
  }, []);

  const login = async (credentials: LoginDto) => {
    const response = await authService.login(credentials);
    setUser(response.user);
    setToken(response.accessToken);
  };

  const logout = () => {
    clearToken();
    setUser(null);
    window.location.href = '/login';
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        logout,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

### Onboarding Context

```typescript
// context/OnboardingProvider.tsx
interface OnboardingContextType {
  currentStep: OnboardingStep;
  completedSteps: OnboardingStep[];
  onboardingComplete: boolean;
  isLoading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const OnboardingProvider = ({ children }: { children: ReactNode }) => {
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ['onboarding', 'status'],
    queryFn: () => axios.get('/cloud-api/onboarding/status').then(r => r.data),
    staleTime: 5 * 60 * 1000,
    retry: false,
  });

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
      </div>
    );
  }

  const value: OnboardingContextType = {
    currentStep: data?.currentStep ?? 'EMAIL_VERIFICATION',
    completedSteps: data?.completedSteps ?? [],
    onboardingComplete: data?.currentStep === 'COMPLETED',
    isLoading,
    error: error?.message ?? null,
    refetch: async () => { await refetch(); },
  };

  return (
    <OnboardingContext.Provider value={value}>
      {children}
    </OnboardingContext.Provider>
  );
};
```

## URL State

### Search Params

```typescript
import { useSearchParams } from 'react-router-dom';

const ProductList = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  const category = searchParams.get('category') ?? 'all';
  const sort = searchParams.get('sort') ?? 'newest';
  const page = parseInt(searchParams.get('page') ?? '1');

  const { data } = useProducts({ category, sort, page });

  const updateFilter = (key: string, value: string) => {
    setSearchParams(prev => {
      prev.set(key, value);
      prev.set('page', '1');  // Reset page on filter change
      return prev;
    });
  };

  return (
    <>
      <FilterBar
        category={category}
        sort={sort}
        onCategoryChange={(c) => updateFilter('category', c)}
        onSortChange={(s) => updateFilter('sort', s)}
      />
      <ProductGrid products={data?.products} />
      <Pagination page={page} onPageChange={(p) => updateFilter('page', p.toString())} />
    </>
  );
};
```

### Route State

```typescript
import { useNavigate, useLocation } from 'react-router-dom';

// Pass state during navigation
const handleLogin = async (data: LoginFormData) => {
  const response = await login(data);

  if (response.requiresMfa) {
    navigate('/mfa-verify', {
      state: { mfaChallenge: response.mfaChallenge },
      replace: true,
    });
  }
};

// Receive state in destination
const MfaVerifyPage = () => {
  const location = useLocation();
  const { mfaChallenge } = location.state ?? {};

  if (!mfaChallenge) {
    return <Navigate to="/login" replace />;
  }

  return <MfaForm challenge={mfaChallenge} />;
};
```

## Query Key Conventions

### Structure

```typescript
// Entity queries
['user', userId]
['tenant', tenantId]

// List queries with filters
['users', 'list', { page, limit, search }]
['products', 'list', { category, sort }]

// Nested resources
['tenant', tenantId, 'users']
['user', userId, 'settings']

// Aggregations/computed
['dashboard', 'stats']
['user', userId, 'activity', 'summary']
```

### Invalidation Patterns

```typescript
const queryClient = useQueryClient();

// Invalidate single entity
queryClient.invalidateQueries({ queryKey: ['user', userId] });

// Invalidate all user queries
queryClient.invalidateQueries({ queryKey: ['user'] });

// Invalidate lists only
queryClient.invalidateQueries({ queryKey: ['users', 'list'] });

// Invalidate everything
queryClient.invalidateQueries();
```

## Best Practices

<Accordion title="Use Query Hooks, Not Inline Queries">
Create reusable hooks for queries:

```typescript
// ✅ Good - reusable hook
export const useUser = (userId: string) => useQuery({...});

// Usage
const { data } = useUser(userId);

// ❌ Avoid - inline query
const { data } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId),
});
```
</Accordion>

<Accordion title="Separate Server and Client State">
Don't mix TanStack Query with local state for the same data:

```typescript
// ✅ Good - use query data directly
const { data: user } = useUser(userId);
return <span>{user?.name}</span>;

// ❌ Avoid - copying to local state
const { data: user } = useUser(userId);
const [name, setName] = useState(user?.name);  // Sync issues!
```
</Accordion>

<Accordion title="Configure Appropriate Stale Times">
```typescript
// Static data - long stale time
useQuery({
  queryKey: ['config'],
  staleTime: 60 * 60 * 1000,  // 1 hour
});

// Dynamic data - short stale time
useQuery({
  queryKey: ['notifications'],
  staleTime: 30 * 1000,  // 30 seconds
});
```
</Accordion>

<Accordion title="Use Enabled for Conditional Queries">
```typescript
// ✅ Good - use enabled option
const { data } = useUserProfile(userId, {
  enabled: isAuthenticated && !!userId,
});

// ❌ Avoid - conditional hook call
if (isAuthenticated) {
  const { data } = useUserProfile(userId);  // Rules of Hooks violation
}
```
</Accordion>
